import random #Так как выбираем слово из банка слов случайным образом, импортируем рандом
a, b, setups, fl = ["геометрия", "чевиана", "теорема", "сыр", "теплопроводность",
"дискриминант", "уравнение", "построение", "яблоко", "папироса", "шоссе",
"итерация", "дискриминация", "превысокомногорассмотрительствующий",
"водогрязеторфопарафинолечение", "рентгеноэлектрокардиографический",
"увлажнитель"], " ", [0, 0], 0
#В порядке следования: массив с русскими словами,
#строка, используемая для ввода всех данных,
#массив с двумя настройками (визуализации и языка угадываемых слов),
#флаг, меняющий значение на правду при опустошении какого-либо
#банка слов.
ea = ["america", "cheese", "python", "banana", "field", "campfire", "forest", "maths",
"friend", "line", "point", "human", "school", "university", "ship",
"february", "aluminium", "provocatively", "thesaurus", "anonymous"] #Массив с английскими словами
wr, tr = [a, ea], 1
#В порядке следования: массив, объединяющий два банка слова, количество 
#попыток угадывания угадываемого слова
start = """Программа Поле Чудес приветствует вас! Вы должны угадать слово
за как можно меньшее количество попыток: для этого либо угадывайте буквы слова,
либо пытайтесь угадать слово, вводя его полностью (ввод нечувствителен к регистру).
Вы можете пользоваться командами, их полный перечень: /cl - сменить язык
угадываемых слов с русского на английский либо наоборот, /cm - сменить
визуализацию с упрощенной на продвинутую и наоборот (вывод крупных букв работает
только для английских слов), /helpme поможет вывести данный текст еще раз, /used выводит
все уникальные буквы, которые вы угадали в текущем слове через запятую и пробел,
/rest выводит все неиспользованные буквы того алфавита, словом которого является
угадываемое слово. Команды можно вводить в любом вводе.\n"""
print(start)#Выводим первый раз инструкцию
congr = r"""
                                 .''.
       .''.             *''*    :_\/_:     . 
      :_\/_:   .    .:.*_\/_*   : /\ :  .'.:.'.
  .''.: /\ : _\(/_  ':'* /\ *  : '..'.  -=:o:=-
 :_\/_:'.:::. /)\*''*  .|.* '.\'/.'_\(/_'.':'.'
 : /\ : :::::  '*_\/_* | |  -= o =- /)\    '  *
  '..'  ':::'   * /\ * |'|  .'/.\'.  '._____
      *        __*..* |  |     :      |.   |' .---"|
       _*   .-'   '-. |  |     .--'|  ||   | _|    |
    .-'|  _.|  |    ||   '-__  |   |  |    ||      |
    |' | |.    |    ||       | |   |  |    ||      |
 ___|  '-'     '    ""       '-'   '-.'    '`      |____
"""
#Псевдографическая картинка с поздравлением (выводится
#при угадывании слова в продвинутом режиме визуализации)
visual =  [
r"          $$\                       $$\            $$$$$$\            $$\       $$\          $$\       $$\                                                                             $$\                                                                      ",  
r"          $$ |                      $$ |          $$  __$$\           $$ |      \__|         $$ |      $$ |                                                                            $$ |                                                                     ",
r" $$$$$$\  $$$$$$$\   $$$$$$$\  $$$$$$$ | $$$$$$\  $$ /  \__| $$$$$$\  $$$$$$$\  $$\      $$\ $$ |  $$\ $$ |$$$$$$\$$$$\  $$$$$$$\   $$$$$$\   $$$$$$\   $$$$$$\   $$$$$$\   $$$$$$$\ $$$$$$\   $$\   $$\ $$\    $$\ $$\  $$\  $$\ $$\   $$\ $$\   $$\ $$$$$$$$\ ",
r" \____$$\ $$  __$$\ $$  _____|$$  __$$ |$$  __$$\ $$$$\     $$  __$$\ $$  __$$\ $$ |     \__|$$ | $$  |$$ |$$  _$$  _$$\ $$  __$$\ $$  __$$\ $$  __$$\ $$  __$$\ $$  __$$\ $$  _____|\_$$  _|  $$ |  $$ |\$$\  $$  |$$ | $$ | $$ |\$$\ $$  |$$ |  $$ |\____$$  |",
r" $$$$$$$ |$$ |  $$ |$$ /      $$ /  $$ |$$$$$$$$ |$$  _|    $$ /  $$ |$$ |  $$ |$$ |     $$\ $$$$$$  / $$ |$$ / $$ / $$ |$$ |  $$ |$$ /  $$ |$$ /  $$ |$$ /  $$ |$$ |  \__|\$$$$$$\    $$ |    $$ |  $$ | \$$\$$  / $$ | $$ | $$ | \$$$$  / $$ |  $$ |  $$$$ _/ ",
r"$$  __$$ |$$ |  $$ |$$ |      $$ |  $$ |$$   ____|$$ |      $$ |  $$ |$$ |  $$ |$$ |     $$ |$$  _$$<  $$ |$$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |       \____$$\   $$ |$$\ $$ |  $$ |  \$$$  /  $$ | $$ | $$ | $$  $$<  $$ |  $$ | $$  _/   ",
r"\$$$$$$$ |$$$$$$$  |\$$$$$$$\ \$$$$$$$ |\$$$$$$$\ $$ |      \$$$$$$$ |$$ |  $$ |$$ |     $$ |$$ | \$$\ $$ |$$ | $$ | $$ |$$ |  $$ |\$$$$$$  |$$$$$$$  |\$$$$$$$ |$$ |      $$$$$$$  |  \$$$$  |\$$$$$$  |   \$  /   \$$$$$\$$$$  |$$  /\$$\ \$$$$$$$ |$$$$$$$$\ ", 
r" \_______|\_______/  \_______| \_______| \_______|\__|       \____$$ |\__|  \__|\__|     $$ |\__|  \__|\__|\__| \__| \__|\__|  \__| \______/ $$  ____/  \____$$ |\__|      \_______/    \____/  \______/     \_/     \_____\____/ \__/  \__| \____$$ |\________|",
r"                                                            $$\   $$ |                  $$  |                                                $$ |            $$ |                                                                           $$\   $$ |          ",
r"                                                            \$$$$$$  |              $$$$$$  |                                                $$ |            $$ |                                                                           \$$$$$$  |          ", 
r"                                                             \______/               \______/                                                 \__|            \__|                                                                            \______/           "
]
#Большие объемные текстовые буквы. Из них составляется
#английское слово в продвинутом режиме визуализации.
_ = [
r"          ",       
r"          ",
r"          ",
r"          ",
r"          ",
r"          ",
r"          ",
r"          ",
r"          ",
r"          ",
r"__________",
#Нижнее подчеркивание, используемое в продвинутом
#режиме визуализации, определяется отдельно.
]
borders1 = [0, 10, 20, 30, 40, 50, 60, 70, 80, 84, 93, 103, 107, 121, 131, 141, 151, 161, 171, 181, 191, 201, 212, 226, 236, 246, 256]
#Т.к объемные буквы хранятся в строке, мы должны указать границы каждой буквы
def cm(): #Функция смена режима визуализации
    setups[0] = not setups[0]  #Инвертация значения
    if setups[0] == 0: #Вывод сообщения о смене режима в зависимости от текушего режима
        print("Выбран стандартный режим визуализации.")
    else:
        print("Выбран более продвинутый режим визуализации.")
def used(): #Функция вывода всех уникальных угаданных букв текущего угадываемого слова
    print(", ".join(sorted([i for i in set(s2) if i != "_"])))
def rest(): #Функция вывода всех неиспользованных при угадывании текущего слова букв 
    if setups[1] == 1: #Если алфавит английский, пишем все неиспользованные из английского алфавита буквы
        print(", ".join(sorted(list(set([chr(i) for i in range(97, 123)]) - set([i for i in s2 if i != "_"])))))
    else: #Если алфавит русский, пишем все неиспользованные из русского алфавита буквы
        print(", ".join(sorted(list(set([chr(i) for i in range(1072, 1104)]) - set([i for i in s2 if i != "_"])))))
def helpme(): #Функция вывода сообщения-помощника
    print(start)
def cl(): #Функция смены банка слов
    if len(wr[not setups[1]]) == 0: #Если тот банк слов, к которому собирается обратиться пользователь, пуст:
        if setups[1] == 1: #Пишем, что тот банк слов, который хотел выбрать юзер, пуст.
           print("Банк русских слов пуст.")
        else:
           print("Банк английских слов пуст.")
    else: #А если он не пуст
        setups[1] = not setups[1] #Инвертируем значение отвечающего за банк слов параметра
        if setups[1] == 0: #Пишем, что тот банк слов, который хотел выбрать юзер, полон. 
            print("Выбран банк русских слов.")
        else:
            print("Выбран банк английских слов.")
links, func = ["cm", "used", "rest", "cl", "helpme"], [cm, used, rest, cl, helpme]
#В порядке следования: массив с текстовыми значениями (исключая слеш в начале команды) всех команд,
#которые может ввести пользователь, массив со ссылками на все функции, которые может выбрать пользователь. 
while not(len(a) == 0 and len(ea) == 0): #Если хотя бы один банк слов не пуст
    tr = 1 #Сбрасываем количество попыток
    if len(a) == 0 and fl == 0: #Если русский банк слов пуст, и было определено, что банк пуст, в первый раз
        print("Автосмена на английский банк слов (все слова из русского банка слов были использованы.)")
        #Оповещаем о вынужденной смене банка слов, меняем соответствующий параметр в массиве настроек.
        setups[1] = not setups[1]
        #Выбираем в качестве того массива, с которым будем работать, массив с английскими словами
        m = wr[1]
        #Флаг который равен 0 только тогда, когда все банки слов не пусты, становится равным 1.
        fl = 1
    elif len(ea) == 0 and fl == 0: #Если английский банк слов пуст, и было определено, что банк пуст, в первый раз
        print("Автосмена на русский банк слов (все слова из английского банка слов был израсходованы).")
        #Оповещаем о вынужденной смене банка слов, меняем соответствующий параметр в массиве настроек.
        setups[1] = not setups[1]   
         #Выбираем в качестве того массива, с которым будем работать, массив с английскими словами.
        m = wr[0]
         #Флаг который равен 0 только тогда, когда все банки слов не пусты, становится равным 1.
        fl = 1
    else: #А если все банки не пусты
        m = wr[setups[1]]
        #Выбираем банк слов относительно предпочтения пользователя
    if b.lower() != "/cm":  #Если мы следуем по данному куску кода не из-за того, что потребовалась смена визуализации
        ind = random.randint(0, len(m) - 1)
        #Выбираем индекс в массиве случайным образом
        s1 = m[ind]
        #Инициируем строку-эталон, с которой будет сравниваться строка s2(инициирована строкой ниже)
        s2 = list("_" * len(s1))
        #Первоначально она состоит из нижних подчеркиваний, количество которых равно длине строки-эталона s1,
        #но нижние подчеркивания будут заменяться угаданными буквами.
    b = "" #Обнуление строки пользовательского ввода
    while not(str(s1).lower() == "".join(s2) or b.lower() == "".join(s1)): #Если слово не угадано
        #посредством ввода такой строки b, что она без учета регистра совпадает со строкой-эталоном s1
        #и если s2 не совпадает с s1 без учета регистра
        if b in ["/cm", "/cl"]: #Если запрошена к исполнению такая команда, которая требует мгновенного прекращения работы программы
            break #Прерываем выполнение
        if len(set(s2)) == 1 and s2[0] == "_": #Если ни одна буква пока не угадана
            print(*s2, sep=" ")  #Выводим строку s2
        b = input("Попробуйте угадать букву слова либо же все слово без учета регистра.\n").lower().replace("ё", "е")
        #Запрашиваем ввода каких-либо данных, обработаем их с ними. Все ё и Ё заменятся на е.
        tr += 1 #Увеличиваем количество попыток угадывания текущего угадываемого слова.
        while not((len(b) != 1 and b.lower() == "".join(s1)) or (len(b) == 1 and b.lower() in s1 and b.lower() not in s2)):
            if b != "":  #Если строка не пуста
                if len(b) != 1: #Если длина строки больше одного символа
                    if b[0] != "/": #Если введена не команда, то данные введены
                        #в таком формате, который не соответсвует ни формату буквы,
                        #ни формату команды. Просим ввести еще раз
                        print("Введите букву или же попытайтесь угадать слово.")
                    else: #Если введена команда
                        if b[1:].lower() in links: #Если введена существующая команда
                            func[links.index(b[1:].lower())]()
                            #Исполняем ее
                            if b.lower() in ["/cm", "/cl"]:
                                #Если введена такая одна из двух команд, которая требует мгновенного проекращения 
                                break #Прерываем выполнение
                        else: #Если введена несущевствующая функция
                            #Оповещаем о отсутсвии такой функции.
                            print("Такой функции нет.")
                elif len(b) == 1: #Если длина строки равна одному символу
                    #Если буква уже находится в строке s2
                    if b.lower() in s2 and b.lower() != "_":
                        #Оповещаем о этом
                        print("Буква уже угадана Вами.")
                    #Если такой буквы нет в текущем угадываемом слове
                    elif b.lower() not in s1:
                        #Оповещаем о этом
                        print("Такой буквы нет в слове.")
            else: #Если строка пуста
                #Оповещаем о этом
                print("Введена пустая строка.")
            #Необходим новый пользовательский ввод данных, запрашиваем его, меняя ё и Ё на е.
            b = input("Попробуйте угадать букву слова либо же все слово без учета регистра.\n").lower().replace("ё", "е")
            #Увеличиваем количество попыток угадывания текущего угадываемого слова.
            tr += 1
        if b not in ["/cm", "/cl"]:  #Если код выше не был прерван из ввода командой /cl либо командой /cm
            if b.lower() != "".join(s1):  #Если слово не угадано посредством ввода такой строки,
                 #что она без учета регистра совпадает с текущим угадываемым словом
                for i in range(len(s1)):
                    if s1[i] == b.lower(): 
                        s2[i] = b.lower()
                    #Если упрощенный режим визуализации либо продвинутый режим визуализации
                    #(для русского языка не поддерживается)
                    if setups[0] == 0 or (setups[0] == 1 and setups[1] == 0):
                        #Выводим слово
                        if i != len(s1) - 1:
                            print(s2[i], end=" ")
                        else:
                            print(s2[i])
                    elif setups[0] == 1 and setups[1] == 1:
                    #Если же режим визуализации продвинутый
                    #и язык английский
                        #Выводим слово, используя
                        #псевдографические буквы английского алфавита
                        #(в начале программы).
                        for i in visual:
                            for j in s2:
                                if j != "_":
                                    print(i[(borders1[ord(j) - 97]):(borders1[ord(j) - 96])], end="  ")
                                else:
                                    print(_[visual.index(i)], end=" ")
                            print()
            if len(b) == 1:  #Если длина пользовательской строки равна одному символу
                #Оповещаем о угаданной букве либо о угаданных буквах (если в слове несколько)
                #одинаковых букв и данные несколько буквы совпадают с текущим значением строки пользовательского ввода
                print(f'Букв{"а" * (s1.count(b.lower()) == 1) + "ы" * (s1.count(b.lower()) > 1)} \
угадан{"а" * (s1.count(b.lower()) == 1) + "ы" * (s1.count(b.lower()) > 1)}!')
                #Если без учета регистра s1 совпадает с текущим угадываемым словом
                if str(s1).lower() == "".join(s2):
                    #Поздравляем с угаданным словом
                    print("Слово угадано!")
                    #Выводим количество попыток, которые потребовалось для угадывания данного слова
                    print('Количество попыток: ' + str(tr - 1))
                    #Если режим визуализации продвинутый
                    if setups[0] == 1:
                        print(congr)  #Выводим картинку салюта
                    #Если количество попыток равно количество уникальных символов текущего угадываемого слова
                    if (tr - 1) == len(set(s1)):
                        #Отмечаем, что было использовано минимальное количество попыток для угадывания слова
                        print("Минимальное количество попыток!")
                    #Удаляем текущее угадываемое слово из текущего банка слов
                    del m[ind]
            else: #Если слово угадано посредством ввода такой строки,
                 #что она без учета регистра совпадает с текущим угадываемым словом
                #Пишем, что слово угадано вводом такой строки, которая без учета регистра
                #совпадает с текущим угадываемым словом, и пишем, с какой попытки
                #слово было угадано
                print("Слово угадано с попытки " + str(tr - 1) + "! Поздравляю!")
                #Если режим визуализации продвинутый
                if setups[0] == 1:
                    #Выводим картинку салюта
                    print(congr)
                #Удаляем текущее угадываемое слово из текущего банка слов
                del m[ind]
#Если банки слов израсходованы, сообщаем об этом. Конец выполнения программы.
print("Банки слов израсходованы!")
